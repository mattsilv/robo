#!/usr/bin/env node

/**
 * Registry Code Generator
 * Reads features.json + copy.json → generates Swift, TypeScript, and updates landing page.
 *
 * Usage: node registry/generate.js
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, '..');

const features = JSON.parse(readFileSync(join(__dirname, 'features.json'), 'utf-8'));
const copy = JSON.parse(readFileSync(join(__dirname, 'copy.json'), 'utf-8'));

/** Escape a string for embedding in a Swift string literal. */
function swiftEscape(str) {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
}

// ─── Swift Generation ───────────────────────────────────────────────

function generateSwift() {
  const skills = features.skills;
  const agents = features.agents;

  const skillEnumCases = skills
    .filter(s => s.skillType)
    .map(s => `        case ${s.skillType}`)
    .join('\n');

  const uniqueSkillTypes = [...new Set(skills.filter(s => s.skillType).map(s => s.skillType))];
  const skillTypeEnumCases = uniqueSkillTypes.map(st => `        case ${st}`).join('\n');

  const skillEntries = skills.map(s => {
    const skillTypeStr = s.skillType ? `.${s.skillType}` : 'nil';
    const featuredStr = s.featured ? 'true' : 'false';
    return `        Skill(
            id: "${swiftEscape(s.id)}",
            name: "${swiftEscape(s.name)}",
            tagline: "${swiftEscape(s.tagline)}",
            status: .${s.status},
            featured: ${featuredStr},
            skillType: ${skillTypeStr},
            category: .${s.category}
        )`;
  }).join(',\n');

  const agentEntries = agents.map(a => {
    return `        Agent(
            id: "${swiftEscape(a.id)}",
            name: "${swiftEscape(a.name)}",
            description: "${swiftEscape(a.description)}",
            icon: "${swiftEscape(a.icon)}",
            color: "${swiftEscape(a.color)}",
            status: .${a.status}
        )`;
  }).join(',\n');

  const activeSkillTypes = skills
    .filter(s => s.status === 'active' && s.skillType)
    .map(s => `.${s.skillType}`);

  const swift = `// AUTO-GENERATED by registry/generate.js — DO NOT EDIT
import Foundation

// swiftlint:disable file_length

/// Single source of truth for all Robo features and agents.
/// Edit registry/features.json + registry/copy.json, then run: npm run codegen
enum FeatureRegistry {

    enum Status: String, Codable {
        case active
        case coming_soon
        case disabled
    }

    enum Category: String, Codable {
        case sensor
        case workflow
        case platform
    }

    struct Skill: Identifiable {
        let id: String
        let name: String
        let tagline: String
        let status: Status
        let featured: Bool
        let skillType: AgentRequest.SkillType?
        let category: Category
    }

    struct Agent: Identifiable {
        let id: String
        let name: String
        let description: String
        let icon: String
        let color: String
        let status: Status
    }

    static let skills: [Skill] = [
${skillEntries}
    ]

    static let agents: [Agent] = [
${agentEntries}
    ]

    /// Active skill types — use for enabledSkillTypes sets.
    static let activeSkillTypes: Set<AgentRequest.SkillType> = [${activeSkillTypes.join(', ')}]

    /// Active skills only.
    static var activeSkills: [Skill] { skills.filter { $0.status == .active } }

    /// Featured skills — shown on onboarding and marketing surfaces.
    static var featuredSkills: [Skill] { skills.filter { $0.featured } }

    /// Coming soon skills only.
    static var comingSoonSkills: [Skill] { skills.filter { $0.status == .coming_soon } }

    /// Active agents only.
    static var activeAgents: [Agent] { agents.filter { $0.status == .active } }
}

/// Single source of truth for user-facing copy.
/// Edit registry/copy.json, then run: npm run codegen
enum AppCopy {
    enum App {
        static let name = "${swiftEscape(copy.app.name)}"
        static let tagline = "${swiftEscape(copy.app.tagline)}"
        static let ogTitle = "${swiftEscape(copy.app.og_title)}"
        static let ogDescription = "${swiftEscape(copy.app.og_description)}"
    }

    enum Tabs {
        static let capture = "${swiftEscape(copy.tabs.capture)}"
        static let history = "${swiftEscape(copy.tabs.history)}"
        static let chat = "${swiftEscape(copy.tabs.chat)}"
        static let settings = "${swiftEscape(copy.tabs.settings)}"
    }

    enum Footer {
        static let tagline = "${swiftEscape(copy.footer.tagline)}"
    }
}

// swiftlint:enable file_length
`;

  writeFileSync(join(ROOT, 'ios/Robo/Generated/FeatureRegistry.swift'), swift);
  console.log('✓ Generated ios/Robo/Generated/FeatureRegistry.swift');
}

// ─── TypeScript Generation ──────────────────────────────────────────

function generateTypeScript() {
  const ts = `// AUTO-GENERATED by registry/generate.js — DO NOT EDIT

export type FeatureStatus = 'active' | 'coming_soon' | 'disabled';
export type FeatureCategory = 'sensor' | 'workflow' | 'platform';
export type SkillType = ${features.skills.filter(s => s.skillType).map(s => `'${s.skillType}'`).join(' | ')};

export interface Skill {
  id: string;
  name: string;
  tagline: string;
  status: FeatureStatus;
  skillType: SkillType | null;
  category: FeatureCategory;
}

export interface Agent {
  id: string;
  name: string;
  description: string;
  icon: string;
  color: string;
  status: FeatureStatus;
}

export const skills: Skill[] = ${JSON.stringify(features.skills, null, 2)} as const;

export const agents: Agent[] = ${JSON.stringify(features.agents, null, 2)} as const;

export const activeSkills = skills.filter(s => s.status === 'active');
export const comingSoonSkills = skills.filter(s => s.status === 'coming_soon');
export const activeAgents = agents.filter(a => a.status === 'active');

export const copy = ${JSON.stringify(copy, null, 2)} as const;
`;

  writeFileSync(join(ROOT, 'workers/src/generated/features.ts'), ts);
  console.log('✓ Generated workers/src/generated/features.ts');
}

// ─── Landing Page Badge Injection ───────────────────────────────────

function updateLandingPage() {
  const htmlPath = join(ROOT, 'site/index.html');
  let html = readFileSync(htmlPath, 'utf-8');

  // Step 1: Strip ALL existing badges (makes this idempotent and handles status changes)
  html = html.replace(/ <span class="badge-coming-soon">Soon<\/span>/g, '');

  // Step 2: Add badges for current coming_soon skills
  for (const skill of features.skills) {
    if (skill.status === 'coming_soon') {
      const labelRegex = new RegExp(
        `(<span class="feature-label">${escapeRegex(skill.name)})(</span>)`,
        'g'
      );
      html = html.replace(labelRegex, `$1 <span class="badge-coming-soon">Soon</span>$2`);
    }
  }

  // Step 3: Ensure badge CSS exists (only add once)
  if (!html.includes('.badge-coming-soon')) {
    const badgeCSS = `
    .badge-coming-soon {
      font-size: 0.55rem;
      background: rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.5);
      padding: 0.1rem 0.35rem;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      vertical-align: middle;
      margin-left: 0.3rem;
    }`;
    html = html.replace('</style>', badgeCSS + '\n    </style>');
  }

  writeFileSync(htmlPath, html);
  console.log('✓ Updated site/index.html with status badges');
}

function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ─── Shared Constants Generation ────────────────────────────────────

function generateSharedConstants() {
  const skillIds = features.skills.map(s => `  ${s.id.toUpperCase()}: '${s.id}'`).join(',\n');
  const agentIds = features.agents.map(a => `  ${a.id.toUpperCase()}: '${a.id}'`).join(',\n');

  const ts = `// AUTO-GENERATED by registry/generate.js — DO NOT EDIT

/** Skill IDs from registry/features.json */
export const SKILL_IDS = {
${skillIds},
} as const;

/** Agent IDs from registry/features.json */
export const AGENT_IDS = {
${agentIds},
} as const;

/** App copy from registry/copy.json */
export const COPY = ${JSON.stringify(copy, null, 2)} as const;

/** Feature status values */
export type FeatureStatus = 'active' | 'coming_soon' | 'disabled';

/** Feature category values */
export type FeatureCategory = 'sensor' | 'workflow' | 'platform';

/** Skill type values */
export type SkillType = ${features.skills.filter(s => s.skillType).map(s => `'${s.skillType}'`).join(' | ')};
`;

  const outDir = join(ROOT, 'packages/shared/src');
  mkdirSync(outDir, { recursive: true });
  writeFileSync(join(outDir, 'constants.ts'), ts);
  console.log('✓ Generated packages/shared/src/constants.ts');
}

// ─── Run ────────────────────────────────────────────────────────────

generateSwift();
generateTypeScript();
generateSharedConstants();
updateLandingPage();
console.log('\nDone! Registry generated from features.json + copy.json');
